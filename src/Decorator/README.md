# 装饰者模式
动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

## 特点
* 可以用一个或多个装饰者包装一个对象
* 装饰者和被装饰对象有相同的超类，因为装饰者必须可以取代被装饰者，所以在任何需要原始对象的场合，都可以用装饰过的对象代替
* 装饰者可以在所委托被装饰行为之前与/或之后，加上自己的行为，以达到特定的目的
* 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用喜欢的装饰者来装饰对象

## 分析
关于咖啡和调料的例子，我们通常所能想到的最佳例子应该就是：
* 定义一个调料超类
* 定义一个咖啡超类，包含添加调料方法
* 最后在咖啡超类中计算咖啡和所有调料的价格

这样，我们合理使用了继承、多态，以及面向接口编程，所有的一切开起来非常完美，短期内也看不出有什么缺陷，但是它隐藏着继承所带来的固有缺陷：**依赖继承来获取行为**，其可扩展的弹性远远低于装饰者模式。
