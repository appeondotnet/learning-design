# 单例模式
使用场景：在项目中只需要实现一次的类，并且其他类都使用的时候都需要获取到这个类的同一个实例。  
例如语法服务器开启的时候需要初始化启动，之后在其他地方使用需要直接拿到这个已初始化的实例，而不能再次实例化一个新的实例。  

总结：确保一个类只有一个实例，并且提供全局访问。  

# 抽象工厂模式
使用场景：系列化类型变化，而具体产品不变化的情况，例如案例中的游戏资源生成器。  
目前已有两种系列分别为：古典和现代。四种资源组件：建筑、隧道、草丛、道路。  
在这种情况下，如果需要增加一个新的系列“未来”，则只需要增加一个FutureFactory，然后继承FacilitiesFactory实现，在具体化实现未来系列的资源组件，而不会对其他系列产生任何影响。  

不适用场景：在本案例中，如果要增加一种资源组件，则整个项目都受到改动，需要新增资源接口，然后在抽象工厂需要定义，在具体工厂需要实现，并且需要新增加资源实例。  

总结：适合于系列或者风格变动的项目，但是具体的组件或者产品数量不发生改变的场景。  

# 命令模式
概述:将请求封装成对象，可以让使用者使用不同的请求、队列、或者日志来参数化其他对象，并且命令模式可以支持撤销操作。  

要点：
1.命令模式将发出请求的对象和执行请求的对象解耦。  
2.在被解耦得到两者之间是通过命令对象进行沟通的，命令对象封装了接收者和一个或者一组动作。  
3.调用者通过调用命令对象的Execute()发出请求，这会使得接收者的动作被调用。  
4.调用者可以接受命令当做参数，甚至在运行时动态地进行。  
5.命令可以支持撤销，做法是实现一个Undo()方法来回到Execute()被执行前的状态。  
6.宏命令是命令的一种简单延伸，允许调用多个命令。宏方法也可以支持撤销。  
7.实际操作时，很常见使用“聪明”命令对象，他就是直接实现了请求，而不是将工作委托给了接收者。  
8.命令也可以用来实现日志和事务系统。  

# 设计原则
1.封装变化。  
2.多用组合，少用继承。  
3.针对接口编程，不针对实现编程。  
4.为交互对象之间的松耦合设计而努力。  
5.类应该对扩展开放，对修改关闭。  
6.依赖抽象，而不依赖具体实现。  

## 目录
[单例模式](https://github.com/appeondotnet/learning-design/tree/pengsongkun/SingletonPattern)
[抽象工厂模式](https://github.com/appeondotnet/learning-design/tree/pengsongkun/AbstractFactoryPattern)
