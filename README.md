# 单例模式
使用场景：在项目中只需要实现一次的类，并且其他类都使用的时候都需要获取到这个类的同一个实例。  
例如语法服务器开启的时候需要初始化启动，之后在其他地方使用需要直接拿到这个已初始化的实例，而不能再次实例化一个新的实例。  

总结：确保一个类只有一个实例，并且提供全局访问。  

# 抽象工厂模式
使用场景：系列化类型变化，而具体产品不变化的情况，例如案例中的游戏资源生成器。  
目前已有两种系列分别为：古典和现代。四种资源组件：建筑、隧道、草丛、道路。  
在这种情况下，如果需要增加一个新的系列“未来”，则只需要增加一个FutureFactory，然后继承FacilitiesFactory实现，在具体化实现未来系列的资源组件，而不会对其他系列产生任何影响。  

不适用场景：在本案例中，如果要增加一种资源组件，则整个项目都受到改动，需要新增资源接口，然后在抽象工厂需要定义，在具体工厂需要实现，并且需要新增加资源实例。  

总结：适合于系列或者风格变动的项目，但是具体的组件或者产品数量不发生改变的场景。  

# 命令模式
概述:将请求封装成对象，可以让使用者使用不同的请求、队列、或者日志来参数化其他对象，并且命令模式可以支持撤销操作。  

要点：  
1.命令模式将发出请求的对象和执行请求的对象解耦。  
2.在被解耦得到两者之间是通过命令对象进行沟通的，命令对象封装了接收者和一个或者一组动作。  
3.调用者通过调用命令对象的Execute()发出请求，这会使得接收者的动作被调用。  
4.调用者可以接受命令当做参数，甚至在运行时动态地进行。  
5.命令可以支持撤销，做法是实现一个Undo()方法来回到Execute()被执行前的状态。  
6.宏命令是命令的一种简单延伸，允许调用多个命令。宏方法也可以支持撤销。  
7.实际操作时，很常见使用“聪明”命令对象，他就是直接实现了请求，而不是将工作委托给了接收者。  
8.命令也可以用来实现日志和事务系统。  

# 适配器模式&外观模式
适配器模式：通过建立一个适配器的类来继承目标接口，然后在适配器中实现需要被适配的对象实例，在接口方法中调用被适配对象的对应方法，达到一个适配器的效果。 
外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

要点： 
1.当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。 
2.当需要简化并且统一一个很大得到接口或者一群复杂的接口时，使用外观。 
3.适配器改变接口以符合客户的期望。 
4.外观将客户从一个复杂的子系统中解耦。 
5.实现一个适配器，可能需要一番功夫，也可能不费工夫，根据目标接口的大小和复杂度而定。 
6.实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。 
7.适配器有两种形式：对象适配器和类适配器，类适配器需要用到多重继承。 
8.你可以为一个子系统实现一个以上的外观。 
9.适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口。 

# 设计原则
1.封装变化。  
2.多用组合，少用继承。  
3.针对接口编程，不针对实现编程。  
4.为交互对象之间的松耦合设计而努力。  
5.类应该对扩展开放，对修改关闭。  
6.依赖抽象，而不依赖具体实现。  
7.最少知道原则：只和你的密友谈话。(迪米特法则)

## 目录
[单例模式](https://github.com/appeondotnet/learning-design/tree/pengsongkun/SingletonPattern)
[抽象工厂模式](https://github.com/appeondotnet/learning-design/tree/pengsongkun/AbstractFactoryPattern)
