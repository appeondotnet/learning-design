# 定义
观察者模式定义了一对多的对象依赖关系，这样一来，如果一个对象的状态发生改变，其它依赖的对象就会收到通知并且自己更新。

# 案例分析
这是一个关于气象站数据变化然后更新一些显示面板的数据的简单案例，在客户提供的WeatherData对象中我们知道当气象站数据更新  
后会调用MetaturedataChanged方法，至于WetatherData对象是怎么获取到气象站的数据我们不需要关心，当气象站数据更新后通知  
三个面板更新，我们需要有个高度可扩展可维护的设计应对用户以后的变化，比如显示面板的添加， 移除...

# 总结  
方案一  
我想很多人都会直接使用第一个方案，这个方案简单粗暴的将三个面板对象耦合进了WetatherData对象，那这样的做法给我们带来了什么  
错误呢
1 违被了针对接口程序， 不针对实现编程  
   三个面板对象类直接在WetaherData中创建使用，这加大了对象间的耦合度  
2 封装变化  
   面板的是可以添加， 可移除的，这样一来当我们需要添加，移除面板对象时都要修改到WeatherData  
  
方案二  
这个方案结合了Java的提供的一套内置的观察模式的实现，其实C#也内置了一套类似的简单的订阅模，  
1 首先定义了主题和观察者的接口，这样一来我们就把具体的观察者从主题中解耦出去，主题只需要关心观察者接口就可以了  
2 主题提供了对观察进行添加，移除的接口，这样就把可变化的部分封装出来，用户可以随意添加，取消通知  
3 观察者接口有一个更新接口，观察者可以通过这个接口拉取所需要的数据， 当然这里有一个有争议的地方， 就是数据应该  
   是让主题推送呢，还是观察者自己拉取所需要的数据，因为主题不想对观察者曝露过多，但观察都又不想关心自己不需要的  
   数据并且每个观察者都可能需要不同的数据，个人倾向拉取的方式。  
  
# 优点
1 完美的处理了对象间的一对多关系  
2 解耦对象间的交互，主题只知道观察者这个接口，并不关心其具体实现

# 缺点  
...

# 扩展  
观察者即可以是一个观察者的同时也可以是个主题，从对象间交互的解耦能力来说，中介者模式也有，只是作用不一样。
