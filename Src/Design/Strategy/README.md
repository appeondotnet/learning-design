#定义
策略模式定义了一组算法，对各个算法分别独立封装，让它们可以相互交换，使用算法的改变独立于使用的客户

#案例分析
案例的最开始使用的OO设计，基于继承的方式实现了鸭子游戏，最开始的方案让鸭子游戏良好的运行了起来，然后有一天客户需要会飞的鸭子，
开发基于现有的方案很快的解决了问题，就是在鸭子的基类中添加Fly方法，这样的就让所有的鸭子都学会了飞，但是有的鸭子是不会飞的，比如
木头鸭子，这让客户很生气，于是开发人员继续改，让不需要飞的鸭子重写Fly方法，可以，这也能解决问题，但是这样一来以后基类作出了改变
你就必需一个一个子类的去检查，哪些需要子类需要，哪些不需要，其实继承的方法很容易造成父类代码入侵，如果子类重写了父类的方法，又
破坏了继承原则，突然有一天，客户需要添加模型鸭子，这个鸭子既不会飞也不会叫， 当然这也难不到我们的开发人员，很好，把会飞的行为和
会叫的形为分别独立出去成为单独的接口，如果你会飞那么你就实现会飞的接口，如果你想叫就实现会叫的接口，想法是很好的，至少把变化的
那部分单独出来封装，但是你有没有想过这可能会造成代码重复过多，于是我们程序员想啊想啊，既然继承不能实现高可维护可扩展性代码，那
么为何不会组合呢，于是很快策略模式就出来，让鸭子持有会飞的接口和会叫的接口，把行为委托给这两个接口去实现，经过不断的锤炼，一个
易于维护，扩展的鸭子游戏就出来，还可以在程序运行的时候改变鸭子的行为，真正做到让模型鸭子不会飞，不会叫，也可以会飞会叫。

#总结
在代码不断改造的后，我们看看其中用到的几个oo原则
1 把飞，叫两个变化的行为分别独立成两个接口， 这体现了封装变化
2 鸭子类依赖的是两个行为接口，它并不知道具体的飞和叫，这样就让具体的行为从鸭子中解耦出去
   这体现了针对接口编程，不针对实现编程
3 鸭子类和行为类组合起来使用，这让程序更灵活，可以在运行的时候改变算法。这体现了多用组合少继承原则，这也是最
   开始鸭子游戏使用鸭子游戏的一些缺陷，比如不好扩展，增加一个行为，一个鸭子品种太困难了
4 飞，叫两个行为的独立封装，这也体现了职责单一原则，现在这两个接口干的事情都很专一。

#优点
1 易于维护，独立的算法互不影响，修改一个算法 并不会影响到其它算法
2 易于扩展，实现一个新算法时非常容易。
3 把具体的算法从客户端解耦出去，用户根本不需要关心算法的内部实现

#缺点
策略模式大概是没有缺点的。让我想想，大概就是当算法较多时，会加大项目的类数量

#扩展
策略模式和状态模式是两个很相似的两个模式，其类图基本一样，但使用的场景却截然不同，一个在于算法的改变，一个在于状态的改变，当状态
改变时其内部的行为也跟着改变，